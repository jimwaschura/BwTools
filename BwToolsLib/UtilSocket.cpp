#include "pch.h"
#include "UtilSocket.h"

/**
* @file UtilSocket.cpp
* UtilSocket class
*/

//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================


#include <stdio.h>
#include "UtilSocket.h"


void print_wsa_error(char* prefix, int num)
{
    wchar_t* s = NULL;

    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, WSAGetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR)&s, 0, NULL);
    printf("%s%S\n", prefix, s);
    LocalFree(s);
}

static bool wsa_initialized = false;

UtilSocket::UtilSocket(int domain) :
    m_Sock(-1),
    m_Destroying(false),
    m_Domain(domain)
{
    int protocol = 0;

    if (wsa_initialized == false)
    {
        wsa_initialized = true;
        WSADATA wsaData = { 0 };

        int status = WSAStartup(MAKEWORD(2, 2), &wsaData);
        if (status != 0)
        {
            printf("WSAStartup failed: %d\n", status);
            throw "[WSA_Init_Failed]";
        }
    }

    if (m_Domain == AF_INET)
        protocol = IPPROTO_TCP;

    m_Sock = socket(domain, SOCK_STREAM, protocol);
    if (getSock() == INVALID_SOCKET)
    {
        throw "[Socket_Open_Error]";
    }
}

/**
* Constructor for UtilSocket class
*
* @details
* Construct UtilSocket object by initializing private variables.
* Use this constructor if you already have an opened socket, say
* from the result of an Accept operation.
*
* @param socknum Socket number (returned from accept)
* @param addrinet Socket address indicating AF_INET domain
*/

UtilSocket::UtilSocket(SOCKET socknum, sockaddr_in addrinet) :
    m_Sock(socknum),
    m_Destroying(false),
    m_Domain(AF_INET)
{
    if (wsa_initialized == false)
    {
        printf("Initializing WSAStartup\n");

        wsa_initialized = true;
        WSADATA wsaData = { 0 };
        int status = WSAStartup(MAKEWORD(2, 2), &wsaData);
        if (status != 0)
        {
            printf("WSAStartup failed: %d\n", status);
            throw "[WSA_Init_Failed]";
        }
    }

    m_SockAddrInet = addrinet;
}

/**
* Destructor for UtilSocket class
*
* @details
* Destruct socket object by closing socket if necessary.  Set
* private m_Destroying flag in case subsequent call to Close()
* wants to know if destructor has been entered.
*/

UtilSocket::~UtilSocket()
{
    m_Destroying = true;

    if (getSock() != -1)
    {
        shutdown(getSock(), SD_BOTH);
        closesocket(getSock());
        m_Sock = -1;
    }
}

/**
* Bind socket to "Any" address for specified port
*
* @details
* Previously-created socket is bound to a specific port, but for any
* IP address.  This is typically used by server function to be able to
* accept connections on a specific port from multiple clients.
*
* @param port Which port to bind to
*/

void UtilSocket::BindToPort(int port)
{
    if (m_Domain != AF_INET)
        throw "[Socket_Bind_Domain_Error]";

    m_SockAddrInet.sin_family = AF_INET;
    m_SockAddrInet.sin_port = htons(port);
    m_SockAddrInet.sin_addr.s_addr = INADDR_ANY;

    if (bind(getSock(), (struct sockaddr*)&m_SockAddrInet, sizeof(m_SockAddrInet)) == SOCKET_ERROR)
        throw "[Socket_Bind_Error]";
}

/**
* Listen for any connection
*
* @details
* Listens for any connection on the specified socket.
*
* @param queueLen species connection queue length
*/

void UtilSocket::Listen(int queueLen)
{
    if (listen(getSock(), queueLen) == SOCKET_ERROR)
        throw "[Socket_Listening_Error]";
}

/**
* Accept connection to client
*
* @details
* Accepts a connection to a client represented by the inbound
* parameter.  Typically, listen is called on a particular socket,
* and if it returns okay, then Accept is called to accept the connection.
*
* @return Socket that has made connection with
*/

UtilSocket* UtilSocket::Accept()
{
    socklen_t size;
    sockaddr* ptr = NULL;
    sockaddr_in addrinet;

    if (m_Domain == AF_INET)
    {
        size = sizeof(sockaddr_in);
        ptr = (sockaddr*)&addrinet;
    }
    else
        throw "[Socket_Bad_Domain]";

    SOCKET newSock = accept(getSock(), ptr, &size);
    if (newSock == INVALID_SOCKET)
        throw "[Socket_Accept_Failed]";

    UtilSocket* retn = NULL;
    retn = new UtilSocket(newSock, addrinet);
    return retn;
}

/**
* Connect to a particular ip address and port
*
* @details
* Used by "client" application to connect to a specific IP Address and port.
*
* @param address Server address, which is run through gethostbyname(),
* @param port Server address port to connect to
*/

void UtilSocket::Connect(const char* address, int port)
{
    struct in_addr* addr_ptr;
    struct hostent* hostPtr;
    char* add;
    try
    {
        hostPtr = gethostbyname(address);
        if (hostPtr == NULL)
            throw "[Socket_No_Hostname]";

        // the first address in the list of host addresses

        addr_ptr = (struct in_addr*)*hostPtr->h_addr_list;

        // changed the address format to the
        // Internet address in standard dot notation

        add = inet_ntoa(*addr_ptr);
        if (add == NULL || *add == 0)
            throw "[Socket_Address_Format_Error]";
    }
    catch (...)
    //catch (int e)
    {
        throw "[Socket_Address_Error]";
    }

    struct sockaddr_in sockAddr;
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = htons(port);
    sockAddr.sin_addr.s_addr = inet_addr(add);

    //	unsigned long ul=1;
    //	int ret=ioctlsocket(getSock(), FIONBIO, (unsigned long *)&ul);//Set into non blocking mode.

    try
    {
        int res = connect(getSock(), (struct sockaddr*)&sockAddr, sizeof(struct sockaddr));

        if (res == SOCKET_ERROR)
        {
            int errnumber = WSAGetLastError();
            print_wsa_error((char*)"connect error:", errnumber);

            fd_set fdset;
            FD_ZERO(&fdset);
            FD_SET(getSock(), &fdset);

            struct timeval connectionTimeout;
            connectionTimeout.tv_sec = 10;
            connectionTimeout.tv_usec = 0;

            res = select((int) getSock() + 1, NULL, &fdset, NULL, &connectionTimeout);
            if (res == 0)
                throw "[Socket_Connect_Timeout]";

            if (res == SOCKET_ERROR)
                throw "[Socket_Select_Error]";
        }

        unsigned long ul = 0;
        int ret = ioctlsocket(getSock(), FIONBIO, (unsigned long*)&ul);//Set into non blocking mode.
    }
    catch (...)
    {
        unsigned long ul = 0;
        int ret = ioctlsocket(getSock(), FIONBIO, (unsigned long*)&ul);//Set into non blocking mode.
        throw;
    }
}

/**
* Send data to socket
*
* @details
* Sends specified number of bytes to socket
*
* @param buff Source location of buffer to transmit
* @param len Number of bytes to transmit
*/

void UtilSocket::Send(char* buffer, int len)

{
    int retn = send(getSock(), buffer, len, 0);
    if (retn == SOCKET_ERROR)
        throw "[Socket_Send_Error]";

    if (retn != len)
        throw "[Socket_Send_Not_Complete]";
}

/**
* Recieve data
*
* @details
* Receive data from a port.  Since no timeouts are set, this is
* a blocking call that will block forever.  Use of signal() is
* required to halt invocation if thread wants to terminate.
*
* @param buffer Destination buffer (bytes)
* @param bufferLen Number of bytes in the destination buffer
* @return Actual number of bytes received (.le. bufferLen)
*/

int UtilSocket::Receive(char* buffer, int bufferLen)
{
    buffer[0] = 0;

    int retn = recv(getSock(), buffer, bufferLen, 0);

    if (retn == SOCKET_ERROR)
        throw "[Socket_Receive_Error]";

    if (retn == 0)
        throw "[Socket_Receive_Zero_Bytes]";

    if (retn < bufferLen)
        buffer[retn] = 0;

    return retn;
}

/**
* Set socket option
*
* @details
* Sets low-level socket options on previously-created socket
*
* @param optname Option name
* @param optval Pointer to option value
* @param optlen Number of bytes in option value
*/

void UtilSocket::SetSocketOption(int optname, const void* optval, int optlen)

{
    if (setsockopt(getSock(), SOL_SOCKET, optname, (const char*)optval, (socklen_t)optlen) == SOCKET_ERROR)
        throw "[Socket_Set_Option_Error]";
}

/**
* Get socket option
*
* @details
* Gets low-level socket options on previously-created socket
*
* @param optname Option name
* @param optval Pointer to option value
* @param optlen Number of bytes in option value
*/

void UtilSocket::GetSocketOption(int optname, void* optval, int* optlen)
{
    *optlen = 0;
    socklen_t x;

    if (getsockopt(getSock(), SOL_SOCKET, optname, (char*)optval, &x) == SOCKET_ERROR)
        throw "[Socket_Get_Option_Error]";

    *optlen = (int)x;
}

/* EOF */





