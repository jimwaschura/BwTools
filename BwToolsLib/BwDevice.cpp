//================================================================================
// BOOST SOFTWARE LICENSE
//
// Copyright 2020 BitWise Laboratories Inc.
// Author.......Jim Waschura
// Contact......info@bitwiselabs.com
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//================================================================================

#include "pch.h"

#include <stdio.h>

#include "BwDevice.h"
#include "UtilTrim.h"

BwDevice::BwDevice() :
	m_ip(NULL),
	m_port(0),
	m_connected(false),
	m_fast_mode(false),
	m_socket(NULL)
{
#ifdef _DEBUG
	printf("BwDevice::BwDevice(), Entered\n");
#endif

	m_socket = new UtilSocket(AF_INET);
}

BwDevice::~BwDevice()
{
#ifdef _DEBUG
	printf("BwDevice::~BwDevice() Entered\n");

#endif
	if (get_connected())
		disconnect();

	delete m_socket;
	m_socket = NULL;
}

void BwDevice::connect(const char* ipAddress, int port)
{
#ifdef _DEBUG
	printf("BwDevice::connect(), Entered with ip=%s, port=%d\n",ipAddress,port);
#endif

	if (get_connected())
		throw "[Already_Connected]";

	get_socket()->Connect( ipAddress, port);

	m_connected = true;
	m_ip = ipAddress;
	m_port = port;
}

void BwDevice::disconnect()
{
#ifdef _DEBUG
	printf("BwDevice::bwdev_disconnect(), Entered\n");
#endif
	
	if (get_connected())
	{
		get_socket()->Send("quit\n", 5);
		m_connected = false;
	}
}

void BwDevice::send_command(const char* fmt, ...)
{
#ifdef _DEBUG
	printf("BwDevice::send_command(), Entered\n");
#endif

	if (!get_connected())
		throw "[Not_Connected]";

	char Buf[4096];
	va_list argptr;
	va_start(argptr, fmt);
	vsnprintf_s(Buf, 4096, fmt, argptr);
	va_end(argptr);

	if (!get_fast_mode())
		clear_status();

#ifdef _DEBUG
	printf("BwDevice::send_command(), send: %s", Buf);
#endif

	get_socket()->Send( Buf, (int)strlen(Buf));

	if (!get_fast_mode())
	{
		get_status( Buf, 4096);

		if (strcmp(Buf, "[none]") != 0)
		{
			static char errmsg[1024];
			snprintf(errmsg, 1024, "[%s]", Buf);
			throw (const char*) errmsg;
		}
	}
}

char * BwDevice::get_status(char* buffer, int buffersize)
{
#ifdef _DEBUG
	printf("BwDevice::get_status(), Entered\n");
#endif

	if (buffer == NULL || buffersize <= 0)
		throw "[Bad_Status_Buffer]";

	buffer[0] = 0;

	if (!get_connected())
		throw "[Not_Connected]";

	get_socket()->Send("st?\n", 4);
	int cnt = get_socket()->Receive(buffer, buffersize - 1);
	if (cnt < buffersize)
		buffer[cnt] = 0;

	trim_string(buffer);

#ifdef _DEBUG
	printf("BwDevice::get_status(), status is: \"%s\"\n", buffer);
#endif

	return buffer;
}

void BwDevice::clear_status()
{
#ifdef _DEBUG
	printf("BwDevice::clear_status(), Entered\n");
#endif

	if (!get_connected())
		throw "[Not_Connected]";

	get_socket()->Send("stc\n", 4);
}

char *BwDevice::query_response( char* buffer, int buffersize, const char* fmt, ...)
{
#ifdef _DEBUG
	printf("BwDevice::query_response, Entered\n");
#endif
	if (buffer == NULL || buffersize <= 0)
		throw "[Bad_Response_Buffer]";

	if (!get_connected())
		throw "[Not_Connected]";

	buffer[0] = 0;
	char Buf[16384];
	va_list argptr;
	va_start(argptr, fmt);
	vsnprintf_s(Buf, 16384, fmt, argptr);

	va_end(argptr);

	if (!get_fast_mode())
		clear_status();

#ifdef _DEBUG
	printf("BwDevice::send_command(), send: %s", Buf);
#endif

	get_socket()->Send(Buf, (int)strlen(Buf));

	int cnt = get_socket()->Receive(buffer, buffersize - 1);
	if (cnt < buffersize)
		buffer[cnt] = 0;

	trim_string(buffer);

#ifdef _DEBUG
	printf("BwDevice::query_response(), response is: \"%s\"\n", buffer);
#endif

	if (!get_fast_mode())
	{
		get_status(Buf, 4096);

		if (strcmp(Buf, "[none]") != 0)
		{
			static char errmsg[1024];
			snprintf(errmsg, 1024, "[%s]", Buf);
			throw (const char*)errmsg;
		}
	}

	return buffer;
}



